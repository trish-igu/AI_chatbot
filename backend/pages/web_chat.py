#!/usr/bin/env python3
"""
Web-based Live Chat Interface using Streamlit.
This provides a beautiful web interface for testing the enhanced multi-agent system.
"""

import streamlit as st
import asyncio
import aiohttp
import json
import uuid
from datetime import datetime
import time

# API Configuration
BASE_URL = "http://localhost:8000"

class WebChatInterface:
    def __init__(self):
        self.session = None
        
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def send_message(self, message: str, conversation_id: str = None, token: str = None):
        """Send a message to the chatbot."""
        payload = {
            "conversation_id": conversation_id,
            "message": message
        }
        
        headers = {"Content-Type": "application/json"}
        if token:
            headers["Authorization"] = f"Bearer {token}"
        
        async with self.session.post(
            f"{BASE_URL}/api/ai/chat",
            json=payload,
            headers=headers
        ) as response:
            if response.status == 200:
                data = await response.json()
                return data
            else:
                error_text = await response.text()
                return {"error": f"Error {response.status}: {error_text}"}

    async def start_conversation(self, token: str = None):
        """Start a new conversation and receive the assistant greeting."""
        headers = {"Content-Type": "application/json"}
        if token:
            headers["Authorization"] = f"Bearer {token}"
        async with self.session.post(f"{BASE_URL}/api/ai/start-conversation", headers=headers) as response:
            if response.status == 200:
                return await response.json()
            else:
                error_text = await response.text()
                return {"error": f"Error {response.status}: {error_text}"}

    async def login_user(self, email: str, password: str):
        """Login user and return token payload or error."""
        async with aiohttp.ClientSession() as s:
            async with s.post(
                f"{BASE_URL}/api/auth/login",
                json={"email": email, "password": password},
                headers={"Content-Type": "application/json"}
            ) as response:
                try:
                    data = await response.json()
                except Exception:
                    data = {"detail": await response.text()}
                if response.status == 200:
                    return {"access_token": data.get("access_token")}
                return {"error": data.get("detail", "Login failed")}

def run_web_chat():
    """Run the web chat interface."""
    st.set_page_config(
        page_title="Live Chat with Mindy",
        page_icon="ü§ñ",
        layout="wide"
    )
    
    st.title("ü§ñ Live Chat with Mindy")
    st.subheader("Enhanced Multi-Agent Mental Health Assistant")
    
    # Initialize session state
    if "conversation_id" not in st.session_state:
        st.session_state.conversation_id = None
    if "messages" not in st.session_state:
        st.session_state.messages = []
    if "session" not in st.session_state:
        st.session_state.session = None
    if "token" not in st.session_state:
        st.session_state.token = None
    if "greeted" not in st.session_state:
        st.session_state.greeted = False
    
    # Inline authentication
    if not st.session_state.token:
        st.header("üîê Login to start chatting")
        with st.form("inline_login_form"):
            email = st.text_input("Email", placeholder="your.email@example.com")
            password = st.text_input("Password", type="password")
            submit_login = st.form_submit_button("Login", type="primary")
        if submit_login:
            if not email or not password:
                st.error("Please fill in both fields")
            else:
                with st.spinner("Logging in..."):
                    result = asyncio.run(inline_login(email, password))
                    if "error" in result:
                        st.error(f"‚ùå {result['error']}")
                    else:
                        st.session_state.token = result["access_token"]
                        st.success("‚úÖ Login successful!")
                        st.rerun()
        return
    
    # Sidebar for controls
    with st.sidebar:
        st.header("üéõÔ∏è Controls")
        
        if st.button("üÜï New Conversation"):
            st.session_state.conversation_id = None
            st.session_state.messages = []
            st.session_state.greeted = False
            st.rerun()
        
        st.header("‚ÑπÔ∏è Info")
        st.write("**User ID:** Generated by backend")
        st.write("**Features:**")
        st.write("‚Ä¢ Personalized greetings")
        st.write("‚Ä¢ Cumulative context")
        st.write("‚Ä¢ Status management")
        st.write("‚Ä¢ HIPAA compliance")
    
    # Offer assistant-initiated greeting for new sessions
    if st.session_state.conversation_id is None and st.button("üëã Start conversation"):
        with st.spinner("Starting a conversation..."):
            result = asyncio.run(start_conversation())
            if result and "error" not in result:
                st.session_state.conversation_id = result["conversation_id"]
                st.session_state.messages.append({"role": "assistant", "content": result["response"]})
                st.session_state.greeted = True
                st.rerun()

    # Auto-start once on first load into an empty chat
    if st.session_state.conversation_id is None and not st.session_state.greeted:
        with st.spinner("Starting a conversation..."):
            result = asyncio.run(start_conversation())
            if result and "error" not in result:
                st.session_state.conversation_id = result["conversation_id"]
                st.session_state.messages.append({"role": "assistant", "content": result["response"]})
                st.session_state.greeted = True
                st.rerun()

    # Main chat interface
    st.header("üí¨ Chat")
    
    # Display messages
    for message in st.session_state.messages:
        with st.chat_message(message["role"]):
            st.write(message["content"])
    
    # Chat input
    if prompt := st.chat_input("Type your message here..."):
        # Ensure a conversation exists before sending the first message
        if st.session_state.conversation_id is None:
            with st.spinner("Starting a conversation..."):
                result = asyncio.run(start_conversation())
                if result and "error" not in result:
                    st.session_state.conversation_id = result["conversation_id"]
                    st.session_state.messages.append({"role": "assistant", "content": result["response"]})
                else:
                    st.error(result.get("error", "Failed to start conversation"))
                    st.stop()

        # Add user message
        st.session_state.messages.append({"role": "user", "content": prompt})
        
        # Display user message
        with st.chat_message("user"):
            st.write(prompt)
        
        # Get AI response
        with st.chat_message("assistant"):
            with st.spinner("Mindy is thinking..."):
                response = asyncio.run(get_ai_response(prompt))
                
                if "error" in response:
                    st.error(response["error"])
                else:
                    st.write(response["response"])
                    st.session_state.conversation_id = response["conversation_id"]
                    st.session_state.messages.append({
                        "role": "assistant", 
                        "content": response["response"]
                    })

async def get_ai_response(message: str):
    """Get AI response for a message."""
    async with WebChatInterface() as chat:
        return await chat.send_message(message, st.session_state.conversation_id, st.session_state.token)

async def start_conversation():
    """Start a new conversation and get the greeting."""
    async with WebChatInterface() as chat:
        return await chat.start_conversation(st.session_state.token)

async def inline_login(email: str, password: str):
    """Perform login and return token payload or error."""
    async with WebChatInterface() as chat:
        return await chat.login_user(email, password)


if __name__ == "__main__":
    run_web_chat()
